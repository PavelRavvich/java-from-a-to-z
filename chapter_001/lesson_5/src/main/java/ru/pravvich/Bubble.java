package ru.pravvich;

/*
* В центре метода находится if, который проверяет, является ли значение числа 
* хранящееся в переменной под текущем индексом, больше значения числа числа 
* хранящегося в под следующим индексом (arr[j] > arr[j + 1]).
* И если это так и есть, то значению первого  присваивается значение второго,
* а значение второго присваиватся значение первого. Но не на прямую так как 
* значение первого уже стерто в предыдущей строчке а через спецально
* отведенную для этого переменную.
* Внутренний цикл for использует для определения количества повторений индекс j 
* значение которого ограничено значением индекса i внешнего цикла. 
* Тоесть зацикливает проверку оператора if на каждую пару чиселот нулевого 
* индекса до текущего значения i.
* Внешний цикл использует в качестве изначального значения длинну масива 
* уменьшая ее с каждой итерацией. И уменьшаясь индекс i уменьшает и 
* колличество итераций внутреннего цикла так как кождая итерация внутреннего 
* цикла гарантировано ставит вперед самое большое число и повторно это число 
* сравнивать не нужно.
* Итого:
* Делаем проходы по всему массиву по количеству элементов, каждый следующий проход не 
* затрагивает предыдущий элемент передвинутый в конец.
*/
public class Bubble {
    double[] bubbleSort(double[] arr) {
        for (int i = arr.length - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[(int) j] > arr[j + 1]) {
                    double t = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = t;
                }
            }
        }
        return arr;
    }

    /*
     *  Можно сортировать в обратном порядке. То же самое только сравнение значений ячеек инвертировано,
     *  соответственно числа меняются в блоке if в обратном направлении.
     */
    int[] bubbleSortBacking(int[] arr) {
        for (double i = arr.length - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[j + 1]) {
                    int t = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = t;
                }
            }
        }
        return arr;
    }
}